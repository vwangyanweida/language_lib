
<!-- vim-markdown-toc GFM -->

* [并发 32]
	* [并发模式  33]
		* [服务访问和配置模式 35]
			* [包装器模式 38]
			* [组件配置器 40]
			* [截取器 41]
			* [扩展接口 42]
		* [事件处理模式 44]
			* [反应器(Reactor)/分配器/通知器]
			* [主动器(Proactor) 46]
			* [异步完成标记(Asynchronous Completion Token, ACT) 47]
			* [接收器-连接器(Acceptor-Connector) 48]
		* [同步模式]
			* [定界加锁(Scoped Locking)]
			* [策略花加锁(strategized Locking)]
			* [线程安全接口]
			* [双检查加锁优化]
		* [并发模式]
			* [主动对象]
			* [监视对象]
			* [半同步/半异步]
			* [领导者/追随者]
			* [线程特定的存储器]
	* [python asyncio 50]
		* [高级接口 51]
			* [Tasks 53]
			* [队列集 54]
			* [子进程集 55]
			* [流 57]
				* [protocol/协议 58]
				* [只读协议 59]
				* [只写协议 60]
				* [读写协议 61]
			* [同步 63]
			* [异常 64]
	* [c++ 原生async 66]
	* [boost asyncio 68]

<!-- vim-markdown-toc -->
# 并发 32
## 并发模式  33
> 面向模式的软件体系结构卷2: p5
### 服务访问和配置模式 35
> 设计模式把现有的非面向对象的API所提供的函数和数据,封装在更加简洁/健壮,可移植,可维护的内聚的面向对象类接口中.

#### 包装器模式 38
> 设计模式允许应用程序不必修改,重新编译,静态的重连接应用程序的情况下,在运行...
#### 组件配置器 40
#### 截取器 41
#### 扩展接口 42

### 事件处理模式 44
#### 反应器(Reactor)/分配器/通知器
0. 概述:
	- 事件驱动的应用可以多路分解并分配从一个或者多个客户机发送给应用的服务请求.
	- 反应器模式引入的机构"逆转"了应用总的控制流,这就是所说的好莱坞规则:不要打电话给我们,我们会给你打电话

1. 情景:
	同时接收多个服务请求,并且依次同步地处理它们的事件驱动应用程序.

2. 怎样应用反应器:
	由指定的组件"反应器",而不是应用程序负责同步等待指示事件,将它们多路分解给负责处理这些事件的事件处理程序,
然后在实践处理程序上分配合适的钩子方法.尤其是,由反应器分配对某一**事件做出反应**的事件处理程序.
这样开发人员只负责实现具体事件处理程序并重用反应器的多路分解和分配机制.

3. 缺陷:
	它不能同时支持大量的客户机或耗时长的客户机请求,因为它在事件多路分解层<font color=green>串行化</font>了
所有的事件处理程序的处理过程,主动器可以有效减小这种限制.

4. 细节
	- 对于应用程序提供的每个服务,引入一个**单独的事件处理程序**处理某一事件源的某一类型的事件.(!某个socket的某个事件的handler处理程序)
	-  在**反应器**中注册所有的事件处理程序,反应器使用一个**同步事件多路分解器**等待一个或多个事件源的指示事件.(!epoll/select事件循环)
	- 发生指示事件后,同步事件多路分解器通知反应器,后者同步分配与事件相关的事件处理程序,
		以便这些事件处理程序可以执行请求的服务.(!反应其不是epoll,是否是IOLoop)
	
5. 结构: 反应器模式有5个主要组成部分
	- 句柄
		- 事件源
		- 指示事件
	- 同步事件多路分解器:一个函数,阻塞,select/epoll
	- 事件处理程序:定义一个或多个钩子方法组成的接口,钩子方法代表操作
	- 具体事件处理程序: 实现应用程序所提供的特定服务的事件处理程序
		- 
	- 反应器: 定义了一个接口,允许应用程序注册或删除事件处理程序及其相应的句柄.
#### 主动器(Proactor) 46
1. 概述
	- 在主动器模式中,客户机和完成处理程序多代表的应用组件称为**主动性实体**.
	- 和被动地等待<font color=green>指示事件的到达并作出响应的反应器模式不同</font>, 
	<font color=red>主动器模式中的客户机和完成处理程序通过在一个异步操作处理器中主动地初始化
	一个或者多个异步操作请求,引起应用程序内部的控制流和数据.</font>
	
	- 异步操作完成后,异步操作处理器和指定的主动器组件协作,将产生的完成事件多路分解给相关的完成处理程序,
	并分配这些处理程序的钩子方法.

#### 异步完成标记(Asynchronous Completion Token, ACT) 47
#### 接收器-连接器(Acceptor-Connector) 48

### 同步模式
#### 定界加锁(Scoped Locking)
#### 策略花加锁(strategized Locking)
#### 线程安全接口
#### 双检查加锁优化

### 并发模式
#### 主动对象
#### 监视对象
#### 半同步/半异步
#### 领导者/追随者
#### 线程特定的存储器

## python asyncio 50
### 高级接口 51
> asyncio/api.md
#### Tasks 53
#### 队列集 54
#### 子进程集 55

#### 流 57
##### protocol/协议 58
##### 只读协议 59
##### 只写协议 60
##### 读写协议 61

#### 同步 63
#### 异常 64

## c++ 原生async 66

## boost asyncio 68
