 
vue logo Vue.js

  • [                    ]
  • 学习
      □ 文档

      □ 
          ☆ 教程
          ☆ API
          ☆ 风格指南
          ☆ 示例
          ☆ Cookbook
      □ 视频教程

      □ 
          ☆ Vue Mastery (英文)
          ☆ Vue School (英文)
          ☆ DCloud 视频教程
  • 生态系统
      □ 帮助

      □ 
          ☆ 论坛
          ☆ 聊天室
          ☆ 聚会
      □ 工具

      □ 
          ☆ Devtools
          ☆ Vue CLI
          ☆ Vue Loader
      □ 核心插件

      □ 
          ☆ Vue Router
          ☆ Vuex
          ☆ Vue 服务端渲染
      □ 信息

      □ 
          ☆ 周刊
          ☆ Roadmap
          ☆ 活动
          ☆ Twitter
          ☆ 博客
          ☆ 工作
  • 团队
  • 资源列表
      □ 合作伙伴
      □ 主题
      □ Awesome Vue
      □ 浏览和 Vue 相关的包
  • 支持 Vue
      □ 一次性赞助
      □ 周期性赞助
      □ 贴纸
      □ 周边
      □ T 恤商店
  • 多语言
      □ English
      □ 日本語
      □ Русский
      □ 한국어
      □ Português
      □ Français
      □ Tiếng Việt
      □ Español
      □ Bahasa Indonesia
  • 参与翻译

特别赞助商
[dcloud]
[imooc-spon]

教程 [2.x ]

  • 基础

  • 安装
  • 介绍
  • Vue 实例
  • 模板语法
  • 计算属性和侦听器
  • Class 与 Style 绑定
  • 条件渲染
  • 列表渲染
  • 事件处理
  • 表单输入绑定
  • 组件基础
  • 深入了解组件

  • 组件注册
  • Prop
  • 自定义事件
  • 插槽
  • 动态组件 & 异步组件
  • 处理边界情况
  • 过渡 & 动画

  • 进入/离开 & 列表过渡
  • 状态过渡
  • 可复用性 & 组合

  • 混入
  • 自定义指令
  • 渲染函数 & JSX
  • 插件
  • 过滤器
  • 工具

  • 单文件组件
  • 单元测试
  • TypeScript 支持
  • 生产环境部署
  • 规模化

  • 路由
  • 状态管理
  • 服务端渲染
  • 安全
  • 内在

  • 深入响应式原理
  • 迁移

  • 从 Vue 1.x 迁移
  • 从 Vue Router 0.7.x 迁移
  • 从 Vuex 0.6.x 迁移到 1.0
  • 更多

  • 对比其他框架
  • 加入 Vue.js 社区
  • 认识团队

广告 Vue.js实战项目开发教程

状态管理

TPshop 中国免费商城系统 - 搜豹商城系统 - 免费50小时 Vue 视频
教程立即查看 >

 类 Flux 状态管理的官方实现

由于状态零散地分布在许多组件和组件之间的交互中，大型应用复杂
度也经常逐渐增长。为了解决这个问题，Vue 提供 vuex：我们有受
到 Elm 启发的状态管理库。vuex 甚至集成到 vue-devtools，无需
配置即可进行时光旅行调试 (time travel debugging)。

在 Vue Mastery 观看视频讲解

 React 的开发者请参考以下信息

如果你是来自 React 的开发者，你可能会对 Vuex 和 Redux 间的差
异表示关注，Redux 是 React 生态环境中最流行的 Flux 实现。
Redux 事实上无法感知视图层，所以它能够轻松的通过一些简单绑定
和 Vue 一起使用。Vuex 区别在于它是一个专门为 Vue 应用所设计
。这使得它能够更好地和 Vue 进行整合，同时提供简洁的 API 和改
善过的开发体验。

 简单状态管理起步使用

经常被忽略的是，Vue 应用中原始 data 对象的实际来源——当访问数
据对象时，一个 Vue 实例只是简单的代理访问。所以，如果你有一
处需要被多个实例间共享的状态，可以简单地通过维护一份数据来实
现共享：

var sourceOfTruth = {}

var vmA = new Vue({
  data: sourceOfTruth
})

var vmB = new Vue({
  data: sourceOfTruth
})

现在当 sourceOfTruth 发生变更，vmA 和 vmB 都将自动地更新它们
的视图。子组件们的每个实例也会通过 this.$root.$data 去访问。
现在我们有了唯一的数据来源，但是，调试将会变为噩梦。任何时间
，我们应用中的任何部分，在任何数据改变后，都不会留下变更过的
记录。

为了解决这个问题，我们采用一个简单的 store 模式：

var store = {
  debug: true,
  state: {
    message: 'Hello!'
  },
  setMessageAction (newValue) {
    if (this.debug) console.log('setMessageAction triggered with', newValue)
    this.state.message = newValue
  },
  clearMessageAction () {
    if (this.debug) console.log('clearMessageAction triggered')
    this.state.message = ''
  }
}

需要注意，所有 store 中 state 的变更，都放置在 store 自身的
action 中去管理。这种集中式状态管理能够被更容易地理解哪种类
型的变更将会发生，以及它们是如何被触发。当错误出现时，我们现
在也会有一个 log 记录 bug 之前发生了什么。

此外，每个实例/组件仍然可以拥有和管理自己的私有状态：

var vmA = new Vue({
  data: {
    privateState: {},
    sharedState: store.state
  }
})

var vmB = new Vue({
  data: {
    privateState: {},
    sharedState: store.state
  }
})

状态管理

重要的是，注意你不应该在 action 中替换原始的状态对象 - 组件
和 store 需要引用同一个共享对象，变更才能够被观察到。

接着我们继续延伸约定，组件不允许直接变更属于 store 实例的
state，而应执行 action 来分发 (dispatch) 事件通知 store 去改
变，我们最终达成了 Flux 架构。这样约定的好处是，我们能够记录
所有 store 中发生的 state 变更，同时实现能做到记录变更、保存
状态快照、历史回滚/时光旅行的先进的调试工具。

说了一圈其实又回到了 Vuex，如果你已经读到这儿，或许可以去尝
试一下！

← 路由服务端渲染 →
发现错误？想参与编辑？在 GitHub 上编辑此页！
