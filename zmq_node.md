
<!-- vim-markdown-toc GFM -->

* [zeromq 模式(socketopt 协议族)](#zeromq-模式socketopt-协议族)
	* [四种zmq核心消息模式：](#四种zmq核心消息模式)
	* [合法的套接字链接对](#合法的套接字链接对)
	* [上层消息模式](#上层消息模式)
		* [zmq多线程](#zmq多线程)
		* [协调](#协调)
		* [zmq 高级请求-应答模式](#zmq-高级请求-应答模式)
			* [信封](#信封)
			* [ROUTER-DEALER 路由](#router-dealer-路由)
			* [REQ-ROUTER](#req-router)
			* [client - ROUTER - code - DEALER - REP](#client---router---code---dealer---rep)
			* [client - ROUTER - code - ROUTER - REQ](#client---router---code---router---req)
			* [异步C/S结构](#异步cs结构)
			* [跨代理路由](#跨代理路由)
			* [丢弃消息](#丢弃消息)
	* [可靠的请求-应答模式](#可靠的请求-应答模式)
		* [如何保障代码运行](#如何保障代码运行)
		* [应答模式的三种连接方式：](#应答模式的三种连接方式)
		* [客户端的可靠性设计(懒惰的海盗模式)](#客户端的可靠性设计懒惰的海盗模式)
		* [基本的可靠队列(简单海盗模式)](#基本的可靠队列简单海盗模式)
		* [健壮的可靠队列(偏执海盗模式)](#健壮的可靠队列偏执海盗模式)
		* [Heartbeat](#heartbeat)
		* [面向服务的可靠队列(管家模式)](#面向服务的可靠队列管家模式)
	* [错误](#错误)
		* [慢链接](#慢链接)

<!-- vim-markdown-toc -->
# zeromq 模式(socketopt 协议族)
[中文文档](https://www.cnblogs.com/fengbohello/p/4230135.html)

## 四种zmq核心消息模式：
1. 请求-应答模式 将一组服务端和一组客户端相连，用于远程过程调用或任务分发。
 
2. 发布-订阅模式 将一组发布者和一组订阅者相连，用于数据分发。
 
3. 管道模式 使用扇入或扇出的形式组装多个节点，可以产生多个步骤或循环，用于构建并行处理架构。
 
4. 排他对接模式 将两个套接字一对一地连接起来，这种模式应用场景很少，我们会在本章最末尾看到一个示例。

## 合法的套接字链接对
1. PUB - SUB
	1. SUB的ZMQ_SUBSCRIBE订阅是前缀匹配，如果只有一帧消息，则从头开始匹配，如果有多帧消息，则j进行第一帧的前缀匹配。

	2. 几点说明：
		- <font color=green>发布者只有写缓存，没有读缓存，只能写，不能读，订阅者相反。</font>
		- 订阅者可以连接多个发布者，轮流接收消息；
		- 如果发布者没有订阅者与之相连，那它发送的消息将直接被丢弃；
	    - 如果你使用TCP协议，那当订阅者处理速度过慢时，消息会在发布者处堆积。
		使用阈值（HWM）来保护发布者。

2. REQ - REP
> 客户端首先使用zmq_send()发送消息，再用zmq_recv()接收，如此循环。如果打乱了这个顺序（如连续发送两次）则会报错。类似地，服务端必须先进行接收，后进行发送

> <font color=green>因为REP没有路由功能，就像它只能记住一个临时变量tmp，send的时候直接将消息发送给这个socket，
每读取一个新消息，就覆盖这个临时变量tmp为新的socket标识需要记住消息来源，
直接顺序执行，REQ发送给REP，REP发送给刚刚读取的那个socket</font> 

	1. REQ-REP必须一问一答，如果多个REQ链接到REP，则REQ排队，REP一个一个处理REQ请求，REP的send会自动关联到刚刚读取的socket，这样多个请求的返回不会出错。
	2. ex

	```
		1 import zmq
		2 import time
		3 import threading
		4 from threading import Thread
		5 import zhelpers
		6
		7 context = zmq.Context()
		8
		9 def work1(context):
		10     w = context.socket(zmq.REQ)
		11     w.connect("tcp://127.0.0.1:8080")
		12     w.send(b"ready")
		13     te = w.recv()
		14     print("te: %s" % te)
		15
		16 def main():
		17     for i in range(10):
		18         Thread(target=work1, args=(context,)).start()
		19
		20     s = context.socket(zmq.REP)
		21     s.bind("tcp://127.0.0.1:8080")
		22
		23     for i in range(10):
		24         zhelpers.dump(s)
		25         s.send(b"kill")
		26
		27 main()
	```

	3. 将24,25行改为
	 
		```
		for i in range(10):
		 zhelpers.dump(s)

		for _ in range(10):
			s.send(b"kill")
		```
	 会报错，因为REP虽然没有根据信封路由的功能，但它可能是顺序执行，读一个REQ，然后send会发送给读取的REQ，然后继续处理下一个REQ.

	4. REQ连接多个REP，REQ会通过负载均衡的方式将请求分发到REP端。但是这样<font color=red>方便添加客户端，但是如果增加服务端，则需要为每个客户端重新配置，记录新添加的服务器的地址。</font>
		这样引出了 REQ - ROUTER - code - DEALEr - REP 的架构模型。

	5. 注意：<font color=red>socket是一个监听，一个链接的，所以ROUTER 直连的是REQ，DEALER直连的是REP，
		ROUTER和DEALER之间需要代码来转发消息。</font>
	
	6. 由5引出内置装置，来自动的转发有ROUTER进来的消息到DEALER. 有三种内置装置：
		- QUEUE: 用作请求-应答模式代理
		- FORWARDER: 用作发布-订阅模式代理
		- STREAMER: 用作管道模式代理

3. REQ - ROUTER
4. DEALER - REP
5. DEALER - ROUTER
	1. <font color=red>DEALER不改变消息帧，也不会路由，也没有REQ和REP的限制。
	它只是把发送缓存负载均衡的发送给连接的socket，然后收取所有接受缓存的内容。没有任何限制。</font> 

	2. <font color=green>DEALER同时有写缓存和读缓存，如果DEALER链接到多个端点，会通过负载均衡的模式发送消息。它本身并没有附加任何其他规则。</font>

6. DEALER - DEALER
7. ROUTER - ROUTER
8. PUSH - PULL 
	1. 分布式处理 
		- PUSH发送消息时会进行负载均衡，如果开启两个接收方，每个只能接受到push消息的一半。
		- PULL套接字会均匀地从多个PUSH处收集消息，这种机制称为公平队列
	2. 像PUB一样，PUSH也只有发送缓存，PULL只有接受缓存。
	
9. PAIR - PAIR: 一对一链接，具有排他性

	其他的组合模式会产生不可预知的结果，在将来的ZMQ版本中可能会直接返回错误。你也可以通过代码去了解这些套接字类型的行为

## 上层消息模式

上文中的四种核心消息模式是内建在ZMQ中的，他们是API的一部分，在ZMQ的C++核心类库中实现，能够保证正确地运行

在这些消息模式之上，我们会建立更为上层的消息模式。这种模式可以用任何语言编写，他们不属于核心类型的一部分，不随ZMQ发行，
只在你自己的应用程序中出现，或者在ZMQ社区中维护

### zmq多线程
1. 如何用ZMQ进行多线程编程，以下是一些规则：

	- 不要在不同的线程之间访问同一份数据，如果要用到传统编程中的互斥机制，那就有违ZMQ的思想了。唯一的例外是ZMQ上下文对象，它是线程安全的。

	- 必须为进程创建ZMQ上下文，并将其传递给所有你需要使用inproc协议进行通信的线程；

	- 你可以将线程作为单独的任务来对待，使用自己的上下文，但是这些线程之间就不能使用inproc协议进行通信了。
	这样做的好处是可以在日后方便地将程序拆分为不同的进程来运行。

	- 不要在不同的线程之间传递套接字对象，这些对象不是线程安全的。从技术上来说，你是可以这样做的，但是会用到互斥和锁的机制，
	这会让你的应用程序变得缓慢和脆弱。唯一合理的情形是，在某些语言的ZMQ类库内部，需要使用垃圾回收机制，这时可能会进行套接字对象的传递。

	- 当你需要在应用程序中使用两个装置时，可能会将套接字对象从一个线程传递给另一个线程，这样做一开始可能会成功，但最后一定会随机地发生错误。
	所以说，应在同一个线程中打开和关闭套接字。

### 协调
1. 线程间传递信号
	协调两个线程工作，发出信号已经启动。
	
### zmq 高级请求-应答模式
#### 信封
> ØMQ使用多段消息的方式来存储信封,所以在复制消息时也会复制信封。

1. 请求-应答模式中使用到的四种套接字类型：

	- DEALER是一种负载均衡，它会将消息分发给已连接的节点，并使用公平队列的机制处理接受到的消息。DEALER的作用就像是PUSH和PULL的结合。

	- REQ发送消息时会在消息顶部插入一个空帧，接受时会将空帧移去。其实REQ是建立在DEALER之上的，但REQ只有当消息发送并接受到回应后才能继续运行。

	- ROUTER在收到消息时会在顶部添加一个信封，标记消息来源。发送时会通过该信封决定哪个节点可以获取到该条消息。

	- REP在收到消息时会将第一个空帧之前的所有信息保存起来，将原始信息传送给应用程序。
	在发送消息时，REP会用刚才保存的信息包裹应答消息。REP其实是建立在ROUTER之上的，但和REQ一样，必须完成接受和发送这两个动作后才能继续。

	- REP要求消息中的信封由一个空帧结束，所以如果你没有用REQ发送消息，则需要自己在消息中添加这个空帧

1. ROUTER中的工作原理
	- 从ROUTER中读取一条消息时，ØMQ会包上一层信封，上面注明了消息的来源。
	- 向ROUTER写入一条消息时（包含信封），ØMQ会将信封拆开，并将消息递送给相应的对象

2. 解释： 例如REQ发送消息到router
	1. REQ将消息发送到直连的ROUTER,ROUTER添加一个标识REQ的address
	2. ROUTER将消息发送给指定的REQ时，需要制定REQ的地址，就是说发送的消息帧必须有地址，而且发送出去后，ROUTER自动将地址帧去掉。

	3. ROUTER 里的信息进来时，加socket标识。
	4. ROUTER 里的信息出去时，使用ROUTER路由功能，拆开信封，将消息发送到信封制定的端点(通过ROUTER生成的标识)

	5. eg:
		
	```
	  1 import zmq
	  2 import time
	  3 import threading
	  4 from threading import Thread
	  5 import zhelpers
	  6
	  7 context = zmq.Context()
	  8
	  9 def work1(context):
	 10     w = context.socket(zmq.REQ)
	 11     w.connect("tcp://127.0.0.1:8080")
	 12     w.send(b"ready")
	 13     te = w.recv()
	 14     print("te: %s, name:%s" % (te, threading.current_thread().name))
	 15
	 16 def rou(context):
	 17     for i in range(10):
	 18         Thread(target=work1, args=(context,)).start()
	 19
	 20     r = context.socket(zmq.ROUTER)
	 21     r.bind("tcp://127.0.0.1:8080")
	 22     res = []
	 23     for i in range(10):
	 24         res.append(r.recv_multipart())
	 25     r.send_multipart([res[0][0], b'', b"this is router"])
	 26
	 27 def main():
	 28     for i in range(10):
	 29         Thread(target=work1, args=(context,)).start()
	 30
	 31     s = context.socket(zmq.REP)
	 32     s.bind("tcp://127.0.0.1:8080")
	 33
	 34     for i in range(10):
	 35         zhelpers.dump(s)
	 36         s.send(b"kill")
	 37
	 38 rou(context)

	```

3. DELAR什么都不干，之时负载均衡将请求发送给后端的REP

4. REP收到消息，会将空帧前面的地址统统保存，空帧后面的信息体发送给用户程序。REQ肯定加一个空帧，REP只将空帧后面数据给用户程序。

5. 具体规则:记得socket是需要连接的，只要send，不需要地址就可以发送到链接的端点。route可以根据信息帧的地址传输。

6. 各种类型socket对信封的处理 
	- ZMQ_REQ模式在发送消息时，ZMQ底层会在消息内容头部插入一个空帧，在接收消息时，会去掉空帧，将内容返回给应用层。

	- ZMQ_REP模式在接收消息时，会将消息空帧之前的信封帧保存起来，将空帧之后的内容传给上层应用。
		上层应用在响应消息时，底层会在响应消息前加上空帧以及对应请求的信封帧。

	- ZMQ_ROUTER模式在接收消息时，ZMQ底层会在消息头部添加上一个信封帧，用于标记消息来源。
		该信封帧可由发送端指定（调用zmq_setsockopt(ZMQ_IDENTITY)），也可由接收端自动生成唯一标识作为信封帧。
		在发送消息时，将信封帧之后的内容发送到以信封帧为标识的地址。

	- ZMQ_DEALER模式，对接收到的消息公平排队fair-queue，以Round-Robin方式发送消息。

5. 特殊：
	- ROUTE是zmq中唯一一个可以定位消息来源的套接字。

#### ROUTER-DEALER 路由
1. ROUTER-DEALDER是一种最简单的路由方式。将ROUTER和多个DEALER相连接，用一种合适的算法来决定如何分发消息给DEALER。
	DEALER可以是一个黑洞（只负责处理消息，不给任何返回）、代理（将消息转发给其他节点）或是服务（会发送返回信息）。

2. 如果你要求DEALER能够进行回复，那就要保证只有一个ROUTER连接到DEALER，因为DEALER并不知道哪个特定的节点在联系它，
	如果有多个节点，它会做负载均衡，将消息分发出去。但如果DEALER是一个黑洞，那就可以连接任何数量的节点。

3. DEALER 可读可写，写的时候，会进行负载均衡。

4. <font color=red>ROUTER 读的时候会添加一个address来标识消息来源，写的时候会去除第一层address，来用这个address路由。</font>

5. 所以通过ROUTER主动写的时候，需要构造一个带地址的消息帧，否则ROUTER会丢弃路由不到的消息帧。

6. example: rtdealer.py

7. ROUTER 并不知道DEALER何时会准备好，需要服务端发来就绪信息。这是ROUTER和PUB需要知道的，他们会丢弃消息。

8. DEALER 就像是PUSH和PULL的结合，但PUSH和PULL不能构建请求应答模式。

#### REQ-ROUTER
1. <font color=red>因为ROUTER发送消息是必须有路由地址，所以先让REQ发送消息，这样ROUTER读的时候自动加上了地址，
	否则要自己构造地址，需要配置文件，还不能扩展</font>

#### client - ROUTER - code - DEALER - REP
DEALER 使用了负载均衡算法，如果要使用其他算法，如LRU算法，需要自定义路由。如下：

#### client - ROUTER - code - ROUTER - REQ
这里最后REQ当做服务器，需要先像中间件注册，然后每次完成任务后主动发请求到代理，还可以当做心跳包，还可以更新worker时间。报告正常。

#### 异步C/S结构
1. Client - DEALER - ROUTER - server - DEALER - DEALER

#### 跨代理路由
#### 丢弃消息
1. 除了ROUTER会丢弃无法路由的消息外，PUB套接字当没有SUB连接它时也会丢弃发送出去的消息。
	其他套接字则会将无法发送的消息存储起来，直到有节点来处理它们。

## 可靠的请求-应答模式
> 简单地来说，可靠性就是当程序发生故障时也能顺利地运行下去

### 如何保障代码运行
1. 请求-应答模式：
	当服务端在处理请求是中断，客户端能够得知这一信息，并停止接收消息，转而选择等待重试、请求另一服务端等操作。这里我们暂不讨论客户端发生问题的情形。

2. 发布-订阅模式：
	如果客户端收到一些消息后意外中止，服务端是不知道这一情况的。发布-订阅模式中的订阅者不会返回任何消息给发布者。
	但是，订阅者可以通过其他方式联系服务端，
	如请求-应答模式，要求服务端重发消息。这里我们暂不讨论服务端发生问题的情形。
	此外，订阅者可以通过某些方式检查自身是否运行得过慢，并采取相应措施（向操作者发出警告、中止等）。

3. 管道模式：
	如果worker意外终止，任务分发器将无从得知。
	管道模式和发布-订阅模式类似，只朝一个方向发送消息。但是，下游的结果收集器可以检测哪项任务没有完成，并告诉任务分发器重新分配该任务。
	如果任务分发器或结果收集器意外中止了，那客户端发出的请求只能另作处理。所以说，系统代码真的要减少出错的几率，因为这很难处理。

### 应答模式的三种连接方式：
1. 客户端连接服务端有三种方式，每种方式都需要不同的可靠性设计：

	- 多个客户端直接和单个服务端进行通信。使用场景：只有一个单点服务器，所有客户端都需要和它通信。需处理的故障：服务器崩溃和重启；网络连接中断。

	- 多个客户端和单个队列装置通信，该装置将请求分发给多个服务端。
		使用场景：任务分发。需处理的故障：worker崩溃和重启，死循环，过载；队列装置崩溃和重启；网络中断。

	- 多个客户端直接和多个服务端通信，无中间件。使用场景：类似域名解析的分布式服务。需处理的故障：服务端崩溃和重启，死循环，过载；网络连接中断。

### 客户端的可靠性设计(懒惰的海盗模式)
1. 步骤：
	- 对REQ套接字进行轮询，当消息抵达时才进行接收；
	- 请求超时后重发消息，循环多次；
	- 若仍无消息，则结束当前事务。

2. 总结：
	1. 客户端连接服务器，等待服务器返回，但是有超时机制，超时还没有返回结果，重试。重试一定次数，还没有接收到结果，认为服务器关闭了，停止访问这个服务器。

	2. 用于单个服务器

### 基本的可靠队列(简单海盗模式)
1. 使用一个队列装置来扩展上述的“懒惰的海盗”模式，使客户端能够透明地和多个服务端通信

2. 总结：
	1. client - REQ - ROUTER - ROUTER - REQ
	2. 客户端依然可以重复n次。
	3. 客户端和服务端都是REQ,通过REQ链接ROUTER,来告诉中间件那个服务器准备好了，可以使用lru算法。

### 健壮的可靠队列(偏执海盗模式)
1. “简单海盗队列”模式工作得非常好，主要是因为它只是两个现有模式的结合体。不过，它也有一些缺点：

	- 该模式无法处理队列的崩溃或重启。client会进行重试，但worker不会重启。
	虽然ZMQ会自动重连worker的套接字，但对于新启动的队列装置来说，由于worker并没有发送“已就绪”的消息，所以它相当于是不存在的。
	为了解决这一问题，我们需要从队列发送心跳给worker，这样worker就能知道队列是否已经死亡。

	- 队列没有检测worker是否已经死亡，所以当worker在处于空闲状态时死亡，队列装置只有在发送了某个请求之后才会将该worker从队列中移除。
	这时，client什么都不能做，只能等待。这不是一个致命的问题，但是依然是不够好的。
	所以，我们需要从worker发送心跳给队列装置，从而让队列得知worker什么时候消亡。

2. 之前我们使用REQ套接字作为worker的套接字类型，但在偏执海盗模式中我们会改用DEALER套接字，
	从而使我们能够任意地发送和接受消息，而不是像REQ套接字那样必须完成发送-接受循环。而DEALER的缺点是我们必须自己管理消息信封

3. 总结：
	1. client - REQ - ROUTER ,Queue, Heartbeat - ROUTER - DEALER - Heartbeat - worker
	2. 

### Heartbeat
1. 用过程中很有可能会产生“虚假故障”的情况，即节点误认为他们已失去连接，因为心跳没有正确地发送。

2. 在理解和实施心跳时，需要考虑以下几点：

	- 心跳不是一种请求-应答，它们异步地在节点之间传递，任一节点都可以通过它来判断对方已经死亡，并中止通信。

	- 如果某个节点使用持久套接字（即设定了套接字标识），意味着发送给它的心跳可能会堆砌，并在重连后一起收到。
	所以说，worker不应该使用持久套接字。示例代码使用持久套接字是为了便于调试，而且代码中使用了随机的套接字标识，避免重用之前的标识。

	- 使用过程中，应先让心跳工作起来，再进行后面的消息处理。你需要保证启动任一节点后，心跳都能正确地执行。停止并重启他们，模拟冻结、崩溃等情况来进行测试。

	- 当你的主循环使用了zmq_poll()，则应该使用另一个计时器来触发心跳。
	不要使用主循环来控制心跳的发送，这回导致过量地发送心跳（阻塞网络），或是发送得太少（导致节点断开）。
	zhelpers包提供了s_clock()函数返回当前系统时间戳，单位是毫秒，可以用它来控制心跳的发送间隔

3. 步骤：
	- 主循环应该使用心跳间隔作为超时时间。显然不能使用无超时时间的设置，而短于心跳间隔也只是浪费循环次数而已。

	- 使用简单的追踪方式来进行追踪，如直接输出至控制台。这里有一些追踪的窍门：使用zmsg()函数打印套接字内容；对消息进行编号，判断是否会有间隔。

	- 在真实的应用程序中，心跳必须是可以配置的，并能和节点共同商定。有些节点需要高频心跳，如10毫秒，另一些节点则可能只需要30秒发送一次心跳即可。

	- 如果你要对不同的节点发送不同频率的心跳，那么poll的超时时间应设置为最短的心跳间隔。

	- 也许你会想要用一个单独的套接字来处理心跳，这看起来很棒，可以将同步的请求-应答和异步的心跳隔离开来。但是，这个主意并不好，
	原因有几点：
		- 首先、发送数据时其实是不需要发送心跳的；
		- 其次、套接字可能会因为网络问题而阻塞，你需要设法知道用于发送数据的套接字停止响应的原因是死亡了还是过于繁忙而已，
	这样你就需要对这个套接字进行心跳。最后，处理两个套接字要比处理一个复杂得多。

	- 我们没有设置client至队列的心跳，因为这太过复杂了，而且没有太大价值。

### 面向服务的可靠队列(管家模式)
1. 管家模式协议（MDP）在扩展PPP协议时引入了一个有趣的特性：
	client发送的每一个请求都有一个“服务名称”，而worker在像队列装置注册时需要告知自己的服务类型。MDP的优势在于它来源于现实编程，协议简单，且容易提升。

## 错误
### 慢链接
1. 出现的套接字：
	- push，感觉没有负载均衡，可能是因为某个pull的启动速度快，
